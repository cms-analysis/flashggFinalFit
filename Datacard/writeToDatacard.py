# Hold defs of writing functions for datacard
import os, sys, re

def writePreamble(f,options):
  f.write("CMS HGG Datacard - %s - 13TeV\n"%(options.years)) 
  f.write("Auto-generated by flashggFinalFits/Datacard/makeDatacard.py\n")
  f.write("Run with: combine\n")
  f.write("---------------------------------------------\n")
  f.write("imax *\n")
  f.write("jmax *\n")
  f.write("kmax *\n")
  f.write("---------------------------------------------\n")
  return True

def writeProcesses(f,d,options):
  f.write("\n")
  # If opt.prune then remove all rows from dataFrame with prune=1
  d = d[d['prune']==0]
  # d = Pandas DataFrame
  # Shapes
  # Loop over categories in dataframe
  for cat in d.cat.unique():
    # Loop over rows for respective category
    for ir,r in d[d['cat']==cat].iterrows():
      # Write to datacard
      f.write("shapes %s %s %s %s\n"%(r['proc'],r['cat'],r['modelWSFile'],r['model']))

  # Bin, observation and rate lines
  lbin_cat = 'bin             '
  lbin_procXcat = 'bin             '
  lobs_cat = 'observation     '
  lproc = 'process         '
  lprocid = 'process         '
  lrate = 'rate            '         
  # Loop over categories
  for cat in d.cat.unique():
    lbin_cat += "%s "%cat
    lobs_cat += "-1 "
    sigID = 0
    # Loop over rows for respective category
    for ir,r in d[d['cat']==cat].iterrows():
      if r['proc'] == "data_obs": continue
      lbin_procXcat += "%s "%cat
      lproc += "%s "%r['proc']
      if r['proc'] == "bkg_mass": lprocid += "1 "
      else:
        lprocid += "%g "%sigID
        sigID -= 1
      lrate += "%.1f "%r['rate']
  #Remove final space from lines and add to file
  f.write("\n")
  for l in [lbin_cat,lbin_procXcat,lobs_cat,lproc,lprocid,lrate]: 
    l = l[:-1]
    f.write("%s\n"%l)
    
  f.write("\n")
  return True

def writeSystematic(f,d,s,options):
  # Remove all rows from dataFrame with prune=1 (includes NoTag)
  d = d[d['prune']==0]

  # If theory: loop over tiers else run over once
  tiers = []
  if s['type']=='theory': tiers = s['tiers']
  else: tiers = ['']
  for tier in tiers:
    if tier != '': tierStr = "_%s"%tier
    else: tierStr = ''
    # Construct syst line/lines if separate by year
    if s['merge'] == 1:
      stitle = "%s%s"%(s['title'],tierStr)
      lsyst = '%-40s    lnN    '%stitle
      # Loop over categories and then iterate over rows in category
      for cat in d.cat.unique():
	for ir,r in d[d['cat']==cat].iterrows():
	  if r['proc'] == "data_obs": continue
	  # Extract value and add to line (with checks)
	  sval = r["%s%s"%(s['name'],tierStr)]
	  lsyst = addSyst(lsyst,sval,stitle,r['proc'],cat)
      # Remove final space from line and add to file
      f.write("%s\n"%lsyst[:-1])
    else:
      for year in options.years.split(","):
	stitle = "%s%s_%s"%(s['title'],tierStr,year)
	sname = "%s%s_%s"%(s['name'],tierStr,year)
	lsyst = '%-40s    lnN    '%stitle
	# Loop over categories and then iterate over rows in category
	for cat in d.cat.unique():
	  for ir,r in d[d['cat']==cat].iterrows():
	    if r['proc'] == "data_obs": continue
	    # Extract value and add to line (with checks)
	    sval = r[sname]
	    lsyst = addSyst(lsyst,sval,stitle,r['proc'],cat)
	# Remove final space from line and add to file
	f.write("%s\n"%lsyst[:-1])
  return True
          

def addSyst(l,v,s,p,c):
  #l-systematic line, v-value, s-systematic title, p-proc, c-cat
  if type(v) is str: 
    l += "%s "%v
    return l
  elif type(v) is list: 
    # Symmetric:
    if len(v) == 1: 
      # Check 1: variation is non-negligible. If not then skip
      if abs(v[0]-1)<0.0005: l += "- "
      # Check 2: variation is not negative. Print message but add to datacard (cleaned later)
      elif v[0] < 0.: 
        print " --> [WARNING] systematic %s: negative variation for (%s,%s)"%(s,p,c)
        l += "%.3f "%v[0]
      else:
        l += "%.3f "%v[0]
    # Anti-symmetirc
    if len(v) == 2:
      # Check 1: variation is non-negligible. If not then skip
      if(abs(v[0]-1)<0.0005)&(abs(v[1]-1)<0.0005): l += '- '
      # Check 2: neither variation is negative. Print message but still add to datacard (cleaned later)
      elif(v[0]<0.)|(v[1]<0.):
        print " --> [WARNING] systematic %s: negative variation for (%s,%s)"%(s,p,c)
        l += "%.3f/%.3f "%(v[0],v[1])
      # Check 3: effect is approximately symmetric: then just add single up variation
      elif( abs((v[0]*v[1])-1)<0.0005 ): l += "%.3f "%v[1]
      else: l += "%.3f/%.3f "%(v[0],v[1])
    return l
  else:
    print " --> [ERROR] systematic %s: value does not have type string or list for (%s,%s). Leaving..."%(s['title'],p,c)
    sys.exit(1)

def writePdfIndex(f,d,options):
  f.write("\n")
  for cat in d[~d['cat'].str.contains("NOTAG")].cat.unique(): f.write("pdfindex_%s_13TeV  discrete\n"%cat)
  return True
